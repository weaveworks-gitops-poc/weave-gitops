// Code generated by counterfeiter. DO NOT EDIT.
package loggerfakes

import (
	"sync"

	"github.com/weaveworks/weave-gitops/pkg/logger"
)

type FakeLogger struct {
	ActionfStub        func(string, ...interface{})
	actionfMutex       sync.RWMutex
	actionfArgsForCall []struct {
		arg1 string
		arg2 []interface{}
	}
	FailurefStub        func(string, ...interface{})
	failurefMutex       sync.RWMutex
	failurefArgsForCall []struct {
		arg1 string
		arg2 []interface{}
	}
	GeneratefStub        func(string, ...interface{})
	generatefMutex       sync.RWMutex
	generatefArgsForCall []struct {
		arg1 string
		arg2 []interface{}
	}
	InfowStub        func(string, ...interface{})
	infowMutex       sync.RWMutex
	infowArgsForCall []struct {
		arg1 string
		arg2 []interface{}
	}
	PrintfStub        func(string, ...interface{})
	printfMutex       sync.RWMutex
	printfArgsForCall []struct {
		arg1 string
		arg2 []interface{}
	}
	PrintlnStub        func(string, ...interface{})
	printlnMutex       sync.RWMutex
	printlnArgsForCall []struct {
		arg1 string
		arg2 []interface{}
	}
	SuccessfStub        func(string, ...interface{})
	successfMutex       sync.RWMutex
	successfArgsForCall []struct {
		arg1 string
		arg2 []interface{}
	}
	WaitingfStub        func(string, ...interface{})
	waitingfMutex       sync.RWMutex
	waitingfArgsForCall []struct {
		arg1 string
		arg2 []interface{}
	}
	WarningfStub        func(string, ...interface{})
	warningfMutex       sync.RWMutex
	warningfArgsForCall []struct {
		arg1 string
		arg2 []interface{}
	}
	WriteStub        func([]byte) (int, error)
	writeMutex       sync.RWMutex
	writeArgsForCall []struct {
		arg1 []byte
	}
	writeReturns struct {
		result1 int
		result2 error
	}
	writeReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeLogger) Actionf(arg1 string, arg2 ...interface{}) {
	fake.actionfMutex.Lock()
	fake.actionfArgsForCall = append(fake.actionfArgsForCall, struct {
		arg1 string
		arg2 []interface{}
	}{arg1, arg2})
	stub := fake.ActionfStub
	fake.recordInvocation("Actionf", []interface{}{arg1, arg2})
	fake.actionfMutex.Unlock()
	if stub != nil {
		fake.ActionfStub(arg1, arg2...)
	}
}

func (fake *FakeLogger) ActionfCallCount() int {
	fake.actionfMutex.RLock()
	defer fake.actionfMutex.RUnlock()
	return len(fake.actionfArgsForCall)
}

func (fake *FakeLogger) ActionfCalls(stub func(string, ...interface{})) {
	fake.actionfMutex.Lock()
	defer fake.actionfMutex.Unlock()
	fake.ActionfStub = stub
}

func (fake *FakeLogger) ActionfArgsForCall(i int) (string, []interface{}) {
	fake.actionfMutex.RLock()
	defer fake.actionfMutex.RUnlock()
	argsForCall := fake.actionfArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLogger) Failuref(arg1 string, arg2 ...interface{}) {
	fake.failurefMutex.Lock()
	fake.failurefArgsForCall = append(fake.failurefArgsForCall, struct {
		arg1 string
		arg2 []interface{}
	}{arg1, arg2})
	stub := fake.FailurefStub
	fake.recordInvocation("Failuref", []interface{}{arg1, arg2})
	fake.failurefMutex.Unlock()
	if stub != nil {
		fake.FailurefStub(arg1, arg2...)
	}
}

func (fake *FakeLogger) FailurefCallCount() int {
	fake.failurefMutex.RLock()
	defer fake.failurefMutex.RUnlock()
	return len(fake.failurefArgsForCall)
}

func (fake *FakeLogger) FailurefCalls(stub func(string, ...interface{})) {
	fake.failurefMutex.Lock()
	defer fake.failurefMutex.Unlock()
	fake.FailurefStub = stub
}

func (fake *FakeLogger) FailurefArgsForCall(i int) (string, []interface{}) {
	fake.failurefMutex.RLock()
	defer fake.failurefMutex.RUnlock()
	argsForCall := fake.failurefArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLogger) Generatef(arg1 string, arg2 ...interface{}) {
	fake.generatefMutex.Lock()
	fake.generatefArgsForCall = append(fake.generatefArgsForCall, struct {
		arg1 string
		arg2 []interface{}
	}{arg1, arg2})
	stub := fake.GeneratefStub
	fake.recordInvocation("Generatef", []interface{}{arg1, arg2})
	fake.generatefMutex.Unlock()
	if stub != nil {
		fake.GeneratefStub(arg1, arg2...)
	}
}

func (fake *FakeLogger) GeneratefCallCount() int {
	fake.generatefMutex.RLock()
	defer fake.generatefMutex.RUnlock()
	return len(fake.generatefArgsForCall)
}

func (fake *FakeLogger) GeneratefCalls(stub func(string, ...interface{})) {
	fake.generatefMutex.Lock()
	defer fake.generatefMutex.Unlock()
	fake.GeneratefStub = stub
}

func (fake *FakeLogger) GeneratefArgsForCall(i int) (string, []interface{}) {
	fake.generatefMutex.RLock()
	defer fake.generatefMutex.RUnlock()
	argsForCall := fake.generatefArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLogger) Infow(arg1 string, arg2 ...interface{}) {
	fake.infowMutex.Lock()
	fake.infowArgsForCall = append(fake.infowArgsForCall, struct {
		arg1 string
		arg2 []interface{}
	}{arg1, arg2})
	stub := fake.InfowStub
	fake.recordInvocation("Infow", []interface{}{arg1, arg2})
	fake.infowMutex.Unlock()
	if stub != nil {
		fake.InfowStub(arg1, arg2...)
	}
}

func (fake *FakeLogger) InfowCallCount() int {
	fake.infowMutex.RLock()
	defer fake.infowMutex.RUnlock()
	return len(fake.infowArgsForCall)
}

func (fake *FakeLogger) InfowCalls(stub func(string, ...interface{})) {
	fake.infowMutex.Lock()
	defer fake.infowMutex.Unlock()
	fake.InfowStub = stub
}

func (fake *FakeLogger) InfowArgsForCall(i int) (string, []interface{}) {
	fake.infowMutex.RLock()
	defer fake.infowMutex.RUnlock()
	argsForCall := fake.infowArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLogger) Printf(arg1 string, arg2 ...interface{}) {
	fake.printfMutex.Lock()
	fake.printfArgsForCall = append(fake.printfArgsForCall, struct {
		arg1 string
		arg2 []interface{}
	}{arg1, arg2})
	stub := fake.PrintfStub
	fake.recordInvocation("Printf", []interface{}{arg1, arg2})
	fake.printfMutex.Unlock()
	if stub != nil {
		fake.PrintfStub(arg1, arg2...)
	}
}

func (fake *FakeLogger) PrintfCallCount() int {
	fake.printfMutex.RLock()
	defer fake.printfMutex.RUnlock()
	return len(fake.printfArgsForCall)
}

func (fake *FakeLogger) PrintfCalls(stub func(string, ...interface{})) {
	fake.printfMutex.Lock()
	defer fake.printfMutex.Unlock()
	fake.PrintfStub = stub
}

func (fake *FakeLogger) PrintfArgsForCall(i int) (string, []interface{}) {
	fake.printfMutex.RLock()
	defer fake.printfMutex.RUnlock()
	argsForCall := fake.printfArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLogger) Println(arg1 string, arg2 ...interface{}) {
	fake.printlnMutex.Lock()
	fake.printlnArgsForCall = append(fake.printlnArgsForCall, struct {
		arg1 string
		arg2 []interface{}
	}{arg1, arg2})
	stub := fake.PrintlnStub
	fake.recordInvocation("Println", []interface{}{arg1, arg2})
	fake.printlnMutex.Unlock()
	if stub != nil {
		fake.PrintlnStub(arg1, arg2...)
	}
}

func (fake *FakeLogger) PrintlnCallCount() int {
	fake.printlnMutex.RLock()
	defer fake.printlnMutex.RUnlock()
	return len(fake.printlnArgsForCall)
}

func (fake *FakeLogger) PrintlnCalls(stub func(string, ...interface{})) {
	fake.printlnMutex.Lock()
	defer fake.printlnMutex.Unlock()
	fake.PrintlnStub = stub
}

func (fake *FakeLogger) PrintlnArgsForCall(i int) (string, []interface{}) {
	fake.printlnMutex.RLock()
	defer fake.printlnMutex.RUnlock()
	argsForCall := fake.printlnArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLogger) Successf(arg1 string, arg2 ...interface{}) {
	fake.successfMutex.Lock()
	fake.successfArgsForCall = append(fake.successfArgsForCall, struct {
		arg1 string
		arg2 []interface{}
	}{arg1, arg2})
	stub := fake.SuccessfStub
	fake.recordInvocation("Successf", []interface{}{arg1, arg2})
	fake.successfMutex.Unlock()
	if stub != nil {
		fake.SuccessfStub(arg1, arg2...)
	}
}

func (fake *FakeLogger) SuccessfCallCount() int {
	fake.successfMutex.RLock()
	defer fake.successfMutex.RUnlock()
	return len(fake.successfArgsForCall)
}

func (fake *FakeLogger) SuccessfCalls(stub func(string, ...interface{})) {
	fake.successfMutex.Lock()
	defer fake.successfMutex.Unlock()
	fake.SuccessfStub = stub
}

func (fake *FakeLogger) SuccessfArgsForCall(i int) (string, []interface{}) {
	fake.successfMutex.RLock()
	defer fake.successfMutex.RUnlock()
	argsForCall := fake.successfArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLogger) Waitingf(arg1 string, arg2 ...interface{}) {
	fake.waitingfMutex.Lock()
	fake.waitingfArgsForCall = append(fake.waitingfArgsForCall, struct {
		arg1 string
		arg2 []interface{}
	}{arg1, arg2})
	stub := fake.WaitingfStub
	fake.recordInvocation("Waitingf", []interface{}{arg1, arg2})
	fake.waitingfMutex.Unlock()
	if stub != nil {
		fake.WaitingfStub(arg1, arg2...)
	}
}

func (fake *FakeLogger) WaitingfCallCount() int {
	fake.waitingfMutex.RLock()
	defer fake.waitingfMutex.RUnlock()
	return len(fake.waitingfArgsForCall)
}

func (fake *FakeLogger) WaitingfCalls(stub func(string, ...interface{})) {
	fake.waitingfMutex.Lock()
	defer fake.waitingfMutex.Unlock()
	fake.WaitingfStub = stub
}

func (fake *FakeLogger) WaitingfArgsForCall(i int) (string, []interface{}) {
	fake.waitingfMutex.RLock()
	defer fake.waitingfMutex.RUnlock()
	argsForCall := fake.waitingfArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLogger) Warningf(arg1 string, arg2 ...interface{}) {
	fake.warningfMutex.Lock()
	fake.warningfArgsForCall = append(fake.warningfArgsForCall, struct {
		arg1 string
		arg2 []interface{}
	}{arg1, arg2})
	stub := fake.WarningfStub
	fake.recordInvocation("Warningf", []interface{}{arg1, arg2})
	fake.warningfMutex.Unlock()
	if stub != nil {
		fake.WarningfStub(arg1, arg2...)
	}
}

func (fake *FakeLogger) WarningfCallCount() int {
	fake.warningfMutex.RLock()
	defer fake.warningfMutex.RUnlock()
	return len(fake.warningfArgsForCall)
}

func (fake *FakeLogger) WarningfCalls(stub func(string, ...interface{})) {
	fake.warningfMutex.Lock()
	defer fake.warningfMutex.Unlock()
	fake.WarningfStub = stub
}

func (fake *FakeLogger) WarningfArgsForCall(i int) (string, []interface{}) {
	fake.warningfMutex.RLock()
	defer fake.warningfMutex.RUnlock()
	argsForCall := fake.warningfArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeLogger) Write(arg1 []byte) (int, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.writeMutex.Lock()
	ret, specificReturn := fake.writeReturnsOnCall[len(fake.writeArgsForCall)]
	fake.writeArgsForCall = append(fake.writeArgsForCall, struct {
		arg1 []byte
	}{arg1Copy})
	stub := fake.WriteStub
	fakeReturns := fake.writeReturns
	fake.recordInvocation("Write", []interface{}{arg1Copy})
	fake.writeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeLogger) WriteCallCount() int {
	fake.writeMutex.RLock()
	defer fake.writeMutex.RUnlock()
	return len(fake.writeArgsForCall)
}

func (fake *FakeLogger) WriteCalls(stub func([]byte) (int, error)) {
	fake.writeMutex.Lock()
	defer fake.writeMutex.Unlock()
	fake.WriteStub = stub
}

func (fake *FakeLogger) WriteArgsForCall(i int) []byte {
	fake.writeMutex.RLock()
	defer fake.writeMutex.RUnlock()
	argsForCall := fake.writeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeLogger) WriteReturns(result1 int, result2 error) {
	fake.writeMutex.Lock()
	defer fake.writeMutex.Unlock()
	fake.WriteStub = nil
	fake.writeReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeLogger) WriteReturnsOnCall(i int, result1 int, result2 error) {
	fake.writeMutex.Lock()
	defer fake.writeMutex.Unlock()
	fake.WriteStub = nil
	if fake.writeReturnsOnCall == nil {
		fake.writeReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.writeReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeLogger) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.actionfMutex.RLock()
	defer fake.actionfMutex.RUnlock()
	fake.failurefMutex.RLock()
	defer fake.failurefMutex.RUnlock()
	fake.generatefMutex.RLock()
	defer fake.generatefMutex.RUnlock()
	fake.infowMutex.RLock()
	defer fake.infowMutex.RUnlock()
	fake.printfMutex.RLock()
	defer fake.printfMutex.RUnlock()
	fake.printlnMutex.RLock()
	defer fake.printlnMutex.RUnlock()
	fake.successfMutex.RLock()
	defer fake.successfMutex.RUnlock()
	fake.waitingfMutex.RLock()
	defer fake.waitingfMutex.RUnlock()
	fake.warningfMutex.RLock()
	defer fake.warningfMutex.RUnlock()
	fake.writeMutex.RLock()
	defer fake.writeMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeLogger) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ logger.Logger = new(FakeLogger)
